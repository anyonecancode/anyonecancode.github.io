{"data":{"markdownRemark":{"html":"<p>Let's say we have an application where, in general, it makes sense to use a relational database. As an example, let's pretend we're running a coffee shop and our system takes care of managing inventory. We put this inventory data to a lot of different uses, from customer-facing use cases like building our menues to business-related use cases like budgeting and deciding what we should buy or not buy. A relational database is a nice fit here as, for each different type of use case, we're interested in different attributes of our data, and we want the flexibility to query our data based on different combinations of those attributes.</p>\n<p>For instance, a coffee cake might have these attributes:</p>\n<pre><code>Name: Can't Resist Coffee Cake\nCategory: Food\nSub Category: Baked Goods\nSupplier: Pop Up Cafe Supply Co.\nCost: 2.00 USD\nCustomer Price: 3.50 USD\nDescription: One of our best sellers, this perfectly-textured,\n  just-the-right-sweetness coffee cake is the perfect accompaniment\n  to your morning joe!\n</code></pre>\n<p>Having only ever eaten at bakeries rather than worked at one, the prices here are probably off, and undoubtedly there are other attributes we'd want to capture (such as nutritional information), but this will work for illustrative purposes.</p>\n<p>Translating this to database table, we might get something like this:</p>\n<pre><code>table: goods\nid   | category | sub_cat | supplier | cost_amt | cost_curr | customer_price_amt | customer_price_curr | name| description\n------------------------------------------------------------------------------------------------------------------\nBigInt Serial | FK      | FK       | FK       | numeric(10,2) | ENUM | numeric(10,2) | ENUM | varchar(128)  | text\n</code></pre>\n<p>And would look like this:\ntable: goods</p>\n<pre><code>id  | category | sub_cat | supplier | cost_amt | cost_curr | customer_price_amt | customer_price_curr | description\n------------------------------------------------------------------------------------------------------------------\n463 | 2        |  4      | 3        |  2.00    | USD        |  3.50             | USD                  |  One of...\n</code></pre>\n<p>Everything seems in order. The current state of our inventory is in an easily queryable, nicely normalized form. Assuming we also have tables to record orders placed, items sold, and so forth, the past state of our inventory is also accessible. What abouth that description field, though? As I noted at the start of this post, in this example this system not only helps us manage business processes like inventory tracking, it also powers the menus. If we change the description in our current approach, that will instantly flow through to the menu as well. Maybe that's what we want, but it puts a lot of pressure on whoever is editing that description -- don't hit \"save\" until the description is exactly right!</p>\n<p>Perhaps what we need is a \"drafts\" table to store data-in-progress that we don't want reflected across the rest of our system yet. What should this table look like? Maybe it essentially be a copy of the <code>goods</code> table, with a few additional colums specific to tracking drafts:</p>\n<pre><code>table: goods_drafts\ndraft_id | good_id | created | all the columns from the goods table....\n--------------------------------\n</code></pre>\n<p>This works, but feels a bit heavy handed. Do we really need to duplicate all the columns from the <code>goods</code> table? Each version of a draft, after all, is by definition immutable -- any changes will just be a new entry in the drafts table. We neither need nor want the ability to run a command like <code>UPDATE goods_drafts SET supplier = 43 WHERE draft_id = 532;</code>. Furthermore, a draft isn't especially relational in nature. Normalizing our database schema so we can query our entire dataset by supplier or category or order placed date makes sense for use cases requiring sorting, filtering, and aggregation, but drafts exist in a state <em>prior</em> to becoming part of our full data set. All we really want to do when saving a draft is to store the state of the record at that point in time, as \"blob\" of data, if you will.</p>\n<p>Applying this insight, lets take a different approach. Instead of replicating the <code>goods</code> table in our <code>goods_drafts</code> table, we can just store the contents of the draft as a json object:</p>\n<pre><code>draft_id | good_id | created | draft\n____________________________________\nBigInt   | FK      | timestamp | jsonb\n</code></pre>\n<p>PostgreSQL actually <a href=\"https://www.postgresql.org/docs/current/datatype-json.html\">offers</a> two json types: <code>json</code> and <code>jsonb</code>. The <code>json</code> type is essentially just a variant on the <code>text</code> type with some additional validation, whereas <code>jsonb</code> internally converts values in the json to their equivalent PostgreSQL datatypes, making for much more efficient storage and allowing indexing and <a href=\"https://www.postgresql.org/docs/current/datatype-json.html#JSON-CONTAINMENT\">containment testing</a>. As the documentation puts it, \"In general, most applications should prefer to store JSON data as jsonb, unless there are quite specialized needs, such as legacy assumptions about ordering of object keys.\"</p>\n<p>This let's us customize our data storage strategy to different use cases while using the same database. When creating or editing an item for sale in our cafe, we can represent it as a json object (which our UI layer is probably already doing anyway) and save it to our database in the same form in our <code>goods_drafts</code> table. We've even accidentally added support for an \"undo\" feature in the UI -- to restore a previous state, simply retrieve the json for an earlier version of the draft.  When our user is happy with their edits and is ready for this data to go \"live,\" we insert or update into the <code>goods</code> table.pWe can have our relational cake and eat our NoSql document stores as well</p>","frontmatter":{"date":"January 20, 2018","path":"/posts/jsonb-drafts","title":"PostgreSQL Jsonb Use Case: Saving Drafts"}}},"pageContext":{}}